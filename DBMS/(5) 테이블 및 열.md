# 테이블
- 테이블(Table)은 실제 데이터(레코드, Record)를 담기 위해 사용한다.
- 테이블 명명법: 단/복수형 스네이크 케이스
## 만들기
- 테이블을 만들기 위해 아래와 같이 명령한다.
- 동일한 스키마 내에 같은 이름을 가지는 테이블이 여러개 존재할 수 없다.
>```sql
> CREATE TABLE `[소속 스키마 이름]`.`[테이블 이름]` (
>   [열 구조,...],
>   [제약 조건 구조,...]?
> );
>```
>- 테이블의 이름이 중복되어 오류가 발생하는 것을 방지하기 위해 `IF NOT EXISTS`키워드를 추가할 수 있다.
## 제약조건
- 제약조건(Constraint)은 제약 조건의 종류와 그 조건에 따라 열이 가질수 있는 레코드의 데이터를 제한하여 DBMS 무결성을 보장하기 위해 사용한다.
### 기본키 제약조건
- 기본키 제약조건(Primary Key Constraint)은 해당 테이블이 가지고 있는 열 중 그 의미가 **식별자(Identifier)인 주축**이되는 열에 대한 제약조건이다.
- 하나의 테이블은 여러개의 기본키 제약조건을 가질 수 없다.(가지고 있지 않거나, 하나만 가질수 있다.)
- 레코드에 대한 접근 참조로써, 인덱싱이 발생하여 조회 속도가 빨라질 수 있다.(대부분의 테이블은 하나의 기본키 제약조건을 가지는 것을 기본으로 한다.)
- 기본키 제약조건은 **유니크 제약조건**의 속성을 같이 가져가기 때문에, 기본키로 지정된 열(들)의 값이 중복될 수 없다.
- 기본키 제약조건이 적용된 열은 `NULL`값을 허용하지 않는다.
- 어떠한 열이 정수형이고 `AUTO_INCREMENT`가 적용되기 위해서는 반드시 해당 열이 기본키여야 한다.
- 사용법 : `CONSTRAINT PRIMARY KEY`([`기본키가 될 열 이름,...`])
### 유니크 제약조건
- 유니크 제약조건(Unique Key Constraint)은 해당 열이 가지는 값이 중복되어서는 안 된다는 의미의 제약조건이다.
- 유니크 제약조건은 `NULL`값을 허용하며 `NULL`간에는 중복 검사를 하지 않는다.
- 사용법 : ``CONSTRAINT UNIQUE ([`유니크 키가 될 열 이름,...`])``
### 체크 제약조건
- 레코드 삽입(`INSERT`)시 명시한 조건이 참(`TRUE`)일 때에만 삽입이 발생하도록 하기 위한 제약조건이다.
- 사용법 : `CONSTRAINT CHECK ([조건])`
### 외래키 제약조건
- 외래키 제약조건(Foreign Key Constraint)은 해당 제약조건이 부여된 테이블이 가질 수 있는 열의 데이터로 하여, 다른 테이블(참조 대상이 되는 테이블)이 가지고 있는 데이터로 제한하고자 할 때 사용한다.
- 외래키 피참조 대상이 되는 열은 기본키(Primary Key)이거나 유니크(Unique)여야한다.
- 사용법 : 
> ``` 
> CONSTRAINT FOREIGN KEY ([`외래키 제약 조건 대상 열 이름`,...]) 
>     REFERENCES `[스키마 이름]`.`[테이블 이름]` ([`참조 대상이 되는 열 이름`,...])
>     [ON DELETE CASCADE]?
>     [ON UPDATE CASCADE]? 
> ```
>- `ON DELETE CASCADE`: 외래키 제약조건의 피참조 레코드는 해당 키워드 없이 삭제될 수 없는데, 피참조 레코드가 삭제될 경우 본 레코드도 함께 삭제되게 하기 위해 사용한다.
>- `ON UPDATE CASCADE`: 외래키 제약조건의 피참조 레코드는 해당 키워드 없이 수정될 수 없는데, 피참조 레코드가 수정될 경우 본 레코드도 함께 수정되게 하기 위해 사용한다.
## 조회하기
### 스키마 소속 테이블 조회하기
- 어떠한 스키마에 소속된 테이블을 조회하기 위해 아래와 같이 명령한다.
>```sql
> SHOW TABLES IN `[스키마 이름]`;
>```
### 테이블 열 구조 조회하기
- 어떠한 테이블이 가지고 있는 열의 구조를 조회하기 위해 아래와 같이 명령한다
>```sql
> DESC `[소속 스키마 이름]`.`[대상 테이블 이름]`;
>```
>`DESC` : Describe

## 수정하기
### 테이블 이름 바꾸기
- 테이블의 이름을 변경하기 위해 아래와 같이 명령한다. 단, 소속된 스키마도 변경할 수 있으므로 참고한다.
>```sql
> ALTER TABLE `[소속 스키마 이름]`.`[대상 테이블 이름]` RENAME TO `[신규 스키마 이름]`.`[신규 테이블 이름]`;
>```
>- 테이블의 소속 스키마를 변경하지 않으려면 `소속 스키마 이름`과 `신규 스키마 이름`을 같게하면 된다.
- 스키마의 이름을 변경하는 기능이 없기 때문에, 테이블의 소속 스키마를 위 쿼리를 이용해서 옮긴 뒤, 기존의 스키마를 삭제하는 방식을 채택해야 한다.
### 열 추가하기
- 열을 추가하기 위해 아래와 같이 명령한다.
>```sql
> ALTER TABLE `[소속 스키마 이름]`.`[대상 테이블 이름]` ADD COLUMN `[추가할 열 구조]`;
>```
>- 새로 추가하는 열은 테이블의 가장 마지막 자리에 추가된다.
- 추가할 열의 위치를 명시하고자 한다면 아래와 같이 `AFTER`키워드를 활용할 수 있다.
>```SQL
> ALTER TABLE `[소속 스키마 이름]`.`[대상 테이블 이름]` ADD COLUMN `[추가할 열 구조]` AFTER `[기준 열 이름]`;
>```
>- 새로 추가하는 열은 **기준 열 이름** 바로 뒷 자리에 추가된다.
- 가장 앞 자리에 열을 추가하고자 한다면 아래와 같이 `FIRST`키워드를 활용할 수 있다.
>```SQL
> ALTER TABLE `[소속 스키마 이름]`.`[대상 테이블 이름]` ADD COLUMN `[추가할 열 구조]` FIRST;
>```
>- 새로 추가하는 열은 가장 앞 자리에 추가된다.
### 열 수정하기
#### 열의 이름 변경하기
- 열의 이름만 변경하기 위해 아래와 같이 명령한다.
>```SQL
>   ALTER TABLE `[소속 스키마 이름]`.`[대상 테이블 이름]` RENAME COLUMN `[변경 대상 열 이름]`TO `[새로운 열 이름]`;
>```
>- 해당 기능은 MariaDB DBMS 10.5.2(MySQL 8.0) 버전부터만 지원된다.
#### 열의 타입 (및 구조) 변경하기
- 열의 **이름을 제외**한 타입 및 구조를 변경하기 위해 아래와 같이 명령한다.(선택에 따라 위치도 조정가능.)
>```SQL
>  ALTER TABLE `[소속 스키마 이름]`.`[대상 테이블 이름]` MODIFY COLUMN `[변경 대상 열 이름]`[이름을 제외한 열 구조] [AFTER `[기준 열 이름]`|FIRST]?;
>```
#### 열의 이름, 타입 및 구조 변경하기
- 열의 이름, 타입 및 구조를 변경하기 위해 아래와 같이 명령한다.
>```SQL
> ALTER TABLE `[소속 스키마 이름]`.`[대상 테이블 이름]` CHANGE COLUMN `[변경 대상 열 이름]`[새로운 이름을 포함한 열 구조];
>```
### 열 삭제하기
- 열을 삭제하기 위해 아래와 같이 명령한다.
>```SQL
> ALTER TABLE `[소속 스키마 이름]`.`[대상 테이블 이름]` DROP COLUMN `[삭제할 열 이름]`;
>```
## 삭제하기
- 테이블을 삭제하기 위해 아래와 같이 명령한다.
>```sql
> DROP TABLE [IF EXISTS]? `[소속 스키마 이름]`.`[테이블 이름]`;
>```
>- 존재하지 않는 테이블을 제거하려할 경우 오류가 발생할 수 있는데, 오류가 발생하는 것을 무시하기 위해 `IF EXISTS`키워드를 추가할 수 있다.
- 테이블을 삭제할 경우 이에 종속된 레코드가 모두 삭제되고, 되돌릴 수 없기 떄문에 신중해야 한다.
# 열
- 열(Column)은 레코드 하나가 가지는 데이터의 개수와 구조 등을 제약하기 위해 존재한다.
## 구조
- 열의 구조는 아래와 같다.
>```sql
> [열 이름] [데이터 타입] [NULL|NOT NULL]? [DEFAULT x]? [AUTO_INCREMENT]?
>```
>- `NULL`: 해당 열에 대응되는 레코드의 데이터에 대해 빈 값(`NULL`)을 허용하겠다는 의미이다. 해당 키워드를 생략하여도 `NULL`이 기본 값이다.
>- `NOT NULL`: 해당 열에 대응되는 레코드의 데이터는 비어있을 수 없다(`NULL`일 수 없다)는 의미이다.
>- `DEFAULT x`: 레코드 삽입(`INSERT`)시 해당 열에 대한 언급이 없을 때 `x`값을 기본 값으로 사용하겠다는 의미이다.
>- `AUTO_INCREMENT`: 해당 열이 기본 키(Primary Key)인 정수일 때, 레코드 삽입(`INSERT`)시, 별도의 언급이 없다면 `1`부터 시작하여 `1`씩 증가하는 일종의 순번 기준 값으로 사용하겠다는 의미이다.

# 데이터 타입
## 숫자형
- `TINYINT`: (`1 Byte`): `-128`부터 `127`까지의 정수를 가질 수 있다.
- `SMALL`: (`2 Byte`): `-32768`부터 `32767`까지의 정수를 가질 수 있다.
- `MEDIUMINT`: (`3 Byte`): `-8,388,608`부터 `8,388,607`까지의 정수를 가질 수 있다.
- `INT`: (`4 Byte`): `-2,147,483,648`부터 `2,147,483,647`까지의 정수를 가질 수 있다.
- `BIGINT`: (`8 Byte`): `-9,223,372,036,845,775,808`부터 `9,223,372,036,845,775,807`까지의 정수를 가질 수 있다.
- `[정수형] UNSIGNED`: 부호를 없애 음수부의 숫자 개수만큼 추가적인 양수 값을 가질 수 있다.
- `[정수형](n)`: 정수형이 가지는 범위 내에서 `n`자에 해당하는 정수를 가질 수 있다. 
## 부동 소수형
- `FLOAT`: (`4 Byte`) `-3.4E+38`부터 `3.4E+38`까지의 소수점이 최대 7자리인 실수를 가질 수 있다.
- `DOUBLE`: (`8 Byte`) `-1.79E+308`부터 `1.79E+308`까지의 소수점이 최대 15자리인 실수를 가질 수 있다.
- `[부동 소수형] UNSIGNED`: 부호를 없애 음수부의 숫자 개수만큼 추가적인 양수 값을 가질 수 있다.
- `FLOAT`과 `DOUBLE`이 데이터를 저장하는 방식에 의해 연산 결과나 소수점 끝자리가 크게 틀어질 수 있어 MySQL8.0.17 버전 이후로는 **사용을 지양**하는 것이 표준이다.
## 고정 소수형
- `DECIMAL(x,y)`: (`5~7 Byte`, 유동적) 전체 길이가 `x`, 그 중 소수부의 길이가 `y`인 고정 소수값을 가진다.
  - `x`: 값의 전체 길이로 최대 `65`까지 지정할 수 있다.
  - `y`: 값 중 소수부의 길이로 최대 `30`까지 지정할 수 있다.
## 문자형
- VARCHAR(n): (`2n~4n Byte`) 문자를 담는다. `n`의 최대 값은 `65,535`이다.
  - 테이블 하나가 가지는(일부 데이터 형을 제외한) 열들의 용량 합이 `65,535 Byte`를 초과하면 안되므로 유의해야 한다.
- `TINYTEXT(n)`:(최대 `255 Byte`) 문자를 담는다.
- `TEXT`:(최대 `65,635 Byte`)문자를 담는다.
- `MEDIUMTEXT`:(최대 `16,777,215 Byte` = `16,383 KB` =` 16MB`)문자를 담는다.
- `LONGTEXT`:(최대 `4,294,967,295 Byte` = `4,194,303 KB` = `4,096 MB` = `4GB`) 문자를 담는다.
## 날짜와 시간
- `DATE`:(`3 Byte`)년,월,일
- `TIME`:(`3 Byte`)시,분,초
- `TIME(n)`:(유동적) 시,분,초,밀리초(n)
- `DATETIME`: (`8 Byte`) 년,월,일,시,분,초
- `DATETIME(n)`: (유동적)년,월,일,시,분,초,밀리초(n). `n`은 최대 `6`
- `TIMESTAMP`: (`4 Byte`)년,월,일,시,분,초
- `YEAR`:(`1 Byte`) 년
## 논리형
- `BOOLEAN`: (`1 Byte`)참(`TRUE`)혹은 거짓(`FALSE`)값을 가진다. 사실 타입은 존재하지 않고, `TINYINT(1) UNSIGNED`로 취급된다 이때, 참(`TRUE`)은 `0`이 아닌 수, 거짓(`FALSE`)은 `0`이다.
## 이진 데이터
- 먼 미래에